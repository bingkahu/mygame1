<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>5D_HYPER_SHAPE_SIM</title>
    <style>
        body { margin: 0; background: #020408; color: #00ffcc; font-family: 'Segoe UI', monospace; overflow: hidden; }
        canvas { display: block; filter: drop-shadow(0 0 15px rgba(0, 255, 204, 0.4)); }
        
        #interface {
            position: absolute; top: 20px; left: 20px;
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid #00ffcc; padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
            pointer-events: none;
        }

        .stat { margin-bottom: 10px; font-size: 13px; letter-spacing: 1px; }
        .glitch { animation: scan 2s infinite; color: #ff0055; font-weight: bold; }
        
        @keyframes scan {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        #legal {
            position: absolute; bottom: 15px; right: 20px;
            font-size: 10px; color: #334;
        }
    </style>
</head>
<body>

    <div id="interface">
        <div class="stat">PROJECT_ID: PENTERACT_ALPHA</div>
        <div class="stat">DIMENSIONS: 5 [X, Y, Z, W, V]</div>
        <div class="stat">VERTICES: 32</div>
        <div class="stat">EDGES: 80</div>
        <div class="stat" id="coords">CALCULATING_MATRIX...</div>
        <div class="glitch">LIVE_HYPER_ROTATION_ACTIVE</div>
    </div>

    <div id="legal">SOURCE PROTECTED BY BINGKAHU ENCRYPTION // NO PERMISSION TO DOWNLOAD</div>
    <canvas id="render"></canvas>

<script>
/**
 * 5D TESSERACT SIMULATOR
 * A pure math approach to 5-dimensional spatial rotation.
 */

const Sim = {
    canvas: document.getElementById('render'),
    ctx: null,
    points: [], 
    angle: 0,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.onresize = () => this.resize();
        
        // Build 5D Cube Vertices (2^5 = 32 points)
        for (let i = 0; i < 32; i++) {
            this.points.push([
                i & 1 ? 1 : -1,
                i & 2 ? 1 : -1,
                i & 4 ? 1 : -1,
                i & 8 ? 1 : -1,
                i & 16 ? 1 : -1
            ]);
        }
        
        this.animate();
    },

    resize() {
        this.W = this.canvas.width = window.innerWidth;
        this.H = this.canvas.height = window.innerHeight;
    },

    // Matrix Rotation for N-Dimensional Space
    rotate(p, a) {
        let rotated = [...p];

        // Rotate in the XV Plane (1st and 5th dimension)
        let x = rotated[0] * Math.cos(a) - rotated[4] * Math.sin(a);
        let v = rotated[0] * Math.sin(a) + rotated[4] * Math.cos(a);
        rotated[0] = x; rotated[4] = v;

        // Rotate in the YW Plane (2nd and 4th dimension)
        let y = rotated[1] * Math.cos(a * 0.7) - rotated[3] * Math.sin(a * 0.7);
        let w = rotated[1] * Math.sin(a * 0.7) + rotated[3] * Math.cos(a * 0.7);
        rotated[1] = y; rotated[3] = w;

        // Rotate in the ZV Plane (3rd and 5th dimension)
        let z = rotated[2] * Math.cos(a * 0.3) - rotated[4] * Math.sin(a * 0.3);
        rotated[2] = z; rotated[4] = rotated[2] * Math.sin(a * 0.3) + rotated[4] * Math.cos(a * 0.3);

        return rotated;
    },

    project(p) {
        // Higher dimensions require perspective division at every step
        // 5D -> 4D
        let d5 = 1 / (3 - p[4]);
        let p4 = [p[0] * d5, p[1] * d5, p[2] * d5, p[3] * d5];

        // 4D -> 3D
        let d4 = 1 / (2 - p4[3]);
        let p3 = [p4[0] * d4, p4[1] * d4, p4[2] * d4];

        // 3D -> 2D (Standard Screen projection)
        let d3 = 1 / (1.5 - p3[2]);
        return {
            x: p3[0] * d3 * 500 + this.W / 2,
            y: p3[1] * d3 * 500 + this.H / 2,
            z: p3[2] // Used for depth coloring
        };
    },

    animate() {
        this.ctx.fillStyle = '#020408';
        this.ctx.fillRect(0, 0, this.W, this.H);

        const transformed = this.points.map(p => {
            return this.project(this.rotate(p, this.angle));
        });

        // Draw edges
        this.ctx.lineWidth = 1.5;
        for (let i = 0; i < transformed.length; i++) {
            for (let j = i + 1; j < transformed.length; j++) {
                // Connect points that differ by only 1 bit (adjacent in 5D)
                let distance = 0;
                let val = i ^ j;
                while (val > 0) {
                    if (val & 1) distance++;
                    val >>= 1;
                }

                if (distance === 1) {
                    const depth = (transformed[i].z + transformed[j].z) + 2;
                    this.ctx.strokeStyle = `hsla(170, 100%, 50%, ${depth * 0.3})`;
                    this.ctx.beginPath();
                    this.ctx.moveTo(transformed[i].x, transformed[i].y);
                    this.ctx.lineTo(transformed[j].x, transformed[j].y);
                    this.ctx.stroke();
                }
            }
        }

        this.angle += 0.015;
        document.getElementById('coords').innerText = `V_AXIS_ROT: ${this.angle.toFixed(4)}`;
        requestAnimationFrame(() => this.animate());
    }
};

window.onload = () => Sim.init();
</script>
</body>
</html>
